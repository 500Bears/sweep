# Relevant codebase files:
Here are the relevant files from the codebase. We previously summarized each of the files to help you solve the GitHub issue. These will be your primary reference to solve the problem:

<relevant_files>
<relevant_file index="0">
<file_path>
django/core/management/base.py
</file_path>
<source>
<original_code file_path="django/core/management/base.py" index="0">
"""
Base classes for writing management commands (named commands which can
be executed through ``django-admin`` or ``manage.py``).
"""
import os
import sys
from argparse import ArgumentParser, HelpFormatter
from io import TextIOBase

import django
from django.core import checks
from django.core.exceptions import ImproperlyConfigured
from django.core.management.color import color_style, no_style
from django.db import DEFAULT_DB_ALIAS, connections


class CommandError(Exception):
    """
    Exception class indicating a problem while executing a management
    command.

    If this exception is raised during the execution of a management
    command, it will be caught and turned into a nicely-printed error
    message to the appropriate output stream (i.e., stderr); as a
    result, raising this exception (with a sensible description of the
    error) is the preferred way to indicate that something has gone
    wrong in the execution of a command.
    """
    pass


class SystemCheckError(CommandError):
    """
    The system check framework detected unrecoverable errors.
    """
    pass


class CommandParser(ArgumentParser):
    """
    Customized ArgumentParser class to improve some error messages and prevent
    SystemExit in several occasions, as SystemExit is unacceptable when a
    command is called programmatically.
    """
    def __init__(self, **kwargs):
        self.missing_args_message = kwargs.pop('missing_args_message', None)
        self.called_from_command_line = kwargs.pop('called_from_command_line', None)
        super().__init__(**kwargs)

    def parse_args(self, args=None, namespace=None):
        # Catch missing argument for a better error message
        if (self.missing_args_message and
                not (args or any(not arg.startswith('-') for arg in args))):
            self.error(self.missing_args_message)
        return super().parse_args(args, namespace)

    def error(self, message):
        if self.called_from_command_line:
            super().error(message)
        else:
            raise CommandError("Error: %s" % message)


def handle_default_options(options):
    """
    Include any default options that all commands should accept here
    so that ManagementUtility can handle them before searching for
    user commands.
    """
    if options.settings:
        os.environ['DJANGO_SETTINGS_MODULE'] = options.settings
    if options.pythonpath:
        sys.path.insert(0, options.pythonpath)


def no_translations(handle_func):
    """Decorator that forces a command to run with translations deactivated."""
    def wrapped(*args, **kwargs):
        from django.utils import translation
        saved_locale = translation.get_language()
        translation.deactivate_all()
        try:
            res = handle_func(*args, **kwargs)
        finally:
            if saved_locale is not None:
                translation.activate(saved_locale)
        return res
    return wrapped


</original_code>
<code_summary file_path="django/core/management/base.py" index="0">
- `CommandError`: An exception class that indicates a problem while executing a management command. This exception is caught and turned into a nicely-formatted error message.
- `SystemCheckError`: A subclass of `CommandError` that indicates the system check framework detected unrecoverable errors.
- `CommandParser`: A customized `ArgumentParser` class that improves error messages and prevents `SystemExit` exceptions when a command is called programmatically.
- `handle_default_options`: A function that handles common command-line options, such as setting the `DJANGO_SETTINGS_MODULE` environment variable or adding directories to the Python path.
- `no_translations`: A decorator that forces a command to run with translations deactivated.
- `DjangoHelpFormatter`: A customized `HelpFormatter` that ensures command-specific arguments appear before common arguments in the `--help` output.
- `OutputWrapper`: A wrapper around `stdout` and `stderr` that handles color formatting and ensures consistent line endings.
- `BaseCommand`: The base class for all management commands. Subclasses must implement the `handle()` method, which contains the command's logic. The `execute()` method handles system checks, database connections, and output formatting.
- `AppCommand`: A subclass of `BaseCommand` that takes one or more installed application labels as arguments and performs an action for each application.
- `LabelCommand`: A subclass of `BaseCommand` that takes one or more arbitrary arguments (labels) and performs an action for each label.
</code_summary>

<original_code file_path="django/core/management/base.py" index="1">
class DjangoHelpFormatter(HelpFormatter):
    """
    Customized formatter so that command-specific arguments appear in the
    --help output before arguments common to all commands.
    """
    show_last = {
        '--version', '--verbosity', '--traceback', '--settings', '--pythonpath',
        '--no-color',
    }

    def _reordered_actions(self, actions):
        return sorted(
            actions,
            key=lambda a: set(a.option_strings) & self.show_last != set()
        )

    def add_usage(self, usage, actions, *args, **kwargs):
        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)

    def add_arguments(self, actions):
        super().add_arguments(self._reordered_actions(actions))


class OutputWrapper(TextIOBase):
    """
    Wrapper around stdout/stderr
    """
    @property
    def style_func(self):
        return self._style_func

    @style_func.setter
    def style_func(self, style_func):
        if style_func and self.isatty():
            self._style_func = style_func
        else:
            self._style_func = lambda x: x

    def __init__(self, out, style_func=None, ending='\n'):
        self._out = out
        self.style_func = None
        self.ending = ending

    def __getattr__(self, name):
        return getattr(self._out, name)

    def isatty(self):
        return hasattr(self._out, 'isatty') and self._out.isatty()

    def write(self, msg, style_func=None, ending=None):
        ending = self.ending if ending is None else ending
        if ending and not msg.endswith(ending):
            msg += ending
        style_func = style_func or self.style_func
        self._out.write(style_func(msg))


</original_code>
<code_summary file_path="django/core/management/base.py" index="1">
`DjangoHelpFormatter` class:
- This class is a custom `HelpFormatter` that is used to format the help output for Django management commands.
- The `show_last` attribute is a set of option strings that should be displayed at the end of the help output, after the command-specific arguments.
- The `_reordered_actions()` method is used to sort the command-line arguments so that the command-specific arguments appear before the common arguments.
- The `add_usage()` and `add_arguments()` methods override the corresponding methods in the parent `HelpFormatter` class to use the reordered actions.

`OutputWrapper` class:
- This class is a wrapper around `stdout` and `stderr` that provides additional functionality, such as the ability to apply color formatting to the output.
- The `style_func` property is used to set a function that will be used to apply color formatting to the output. If the output is not a TTY (terminal), the `style_func` is set to a no-op function that simply returns the input string.
- The `write()` method is used to write output to the wrapped stream, applying the `style_func` if it is set.
</code_summary>

<original_code file_path="django/core/management/base.py" index="2">
class BaseCommand:
    """
    The base class from which all management commands ultimately
    derive.

    Use this class if you want access to all of the mechanisms which
    parse the command-line arguments and work out what code to call in
    response; if you don't need to change any of that behavior,
    consider using one of the subclasses defined in this file.

    If you are interested in overriding/customizing various aspects of
    the command-parsing and -execution behavior, the normal flow works
    as follows:

    1. ``django-admin`` or ``manage.py`` loads the command class
       and calls its ``run_from_argv()`` method.

    2. The ``run_from_argv()`` method calls ``create_parser()`` to get
       an ``ArgumentParser`` for the arguments, parses them, performs
       any environment changes requested by options like
       ``pythonpath``, and then calls the ``execute()`` method,
       passing the parsed arguments.

    3. The ``execute()`` method attempts to carry out the command by
       calling the ``handle()`` method with the parsed arguments; any
       output produced by ``handle()`` will be printed to standard
       output and, if the command is intended to produce a block of
       SQL statements, will be wrapped in ``BEGIN`` and ``COMMIT``.

    4. If ``handle()`` or ``execute()`` raised any exception (e.g.
       ``CommandError``), ``run_from_argv()`` will  instead print an error
       message to ``stderr``.

    Thus, the ``handle()`` method is typically the starting point for
    subclasses; many built-in commands and command types either place
    all of their logic in ``handle()``, or perform some additional
    parsing work in ``handle()`` and then delegate from it to more
    specialized methods as needed.

    Several attributes affect behavior at various steps along the way:

    ``help``
        A short description of the command, which will be printed in
        help messages.

    ``output_transaction``
        A boolean indicating whether the command outputs SQL
        statements; if ``True``, the output will automatically be
        wrapped with ``BEGIN;`` and ``COMMIT;``. Default value is
        ``False``.

    ``requires_migrations_checks``
        A boolean; if ``True``, the command prints a warning if the set of
        migrations on disk don't match the migrations in the database.

    ``requires_system_checks``
        A boolean; if ``True``, entire Django project will be checked for errors
        prior to executing the command. Default value is ``True``.
        To validate an individual application's models
        rather than all applications' models, call
        ``self.check(app_configs)`` from ``handle()``, where ``app_configs``
        is the list of application's configuration provided by the
        app registry.

    ``stealth_options``
        A tuple of any options the command uses which aren't defined by the
        argument parser.
    """
    # Metadata about this command.
    help = ''

</original_code>
<code_summary file_path="django/core/management/base.py" index="2">
- The `BaseCommand` class defines the base functionality for all Django management commands. It provides a standard way to handle the parsing of command-line arguments, executing the command, and handling any exceptions that may occur.
- The `help` attribute is a short description of the command, which will be printed in help messages.
- The `output_transaction` attribute indicates whether the command outputs SQL statements, and if `True`, the output will be automatically wrapped with `BEGIN;` and `COMMIT;`.
- The `requires_migrations_checks` attribute indicates whether the command should print a warning if the set of migrations on disk don't match the migrations in the database.
- The `requires_system_checks` attribute indicates whether the entire Django project should be checked for errors prior to executing the command.
- The `stealth_options` attribute is a tuple of any options the command uses which aren't defined by the argument parser.
- The `__init__()` method initializes the `stdout`, `stderr`, and `style` attributes of the command.
- The `get_version()` method returns the Django version, which can be overridden by subclasses to return their own version.
- The `create_parser()` method creates and returns the `ArgumentParser` that will be used to parse the command-line arguments.
- The `add_arguments()` method is an entry point for subclassed commands to add custom arguments to the `ArgumentParser`.
- The `print_help()` method prints the help message for the command, derived from the `self.usage()` method.
- The `run_from_argv()` method is the entry point for the command and is responsible for setting up the environment, parsing the arguments, and calling the `execute()` method.
- The `execute()` method attempts to carry out the command by calling the `handle()` method with the parsed arguments, and handles any exceptions that may occur.
- The `_run_checks()` method uses the system check framework to validate the entire Django project.
- The `check()` method is a wrapper around `_run_checks()` that raises a `SystemCheckError` if any serious messages (errors or critical errors) are found, or prints the messages to `stderr` if there are only light messages (like warnings).
- The `check_migrations()` method prints a warning if the set of migrations on disk don't match the migrations in the database.
- The `handle()` method is where the command-specific logic is implemented, and must be overridden by subclasses.
</code_summary>

<original_code file_path="django/core/management/base.py" index="3">
    # Configuration shortcuts that alter various logic.
    _called_from_command_line = False
    output_transaction = False  # Whether to wrap the output in a "BEGIN; COMMIT;"
    requires_migrations_checks = False
    requires_system_checks = True
    # Arguments, common to all commands, which aren't defined by the argument
    # parser.
    base_stealth_options = ('skip_checks', 'stderr', 'stdout')
    # Command-specific options not defined by the argument parser.
    stealth_options = ()

    def __init__(self, stdout=None, stderr=None, no_color=False):
        self.stdout = OutputWrapper(stdout or sys.stdout)
        self.stderr = OutputWrapper(stderr or sys.stderr)
        if no_color:
            self.style = no_style()
        else:
            self.style = color_style()
            self.stderr.style_func = self.style.ERROR

    def get_version(self):
        """
        Return the Django version, which should be correct for all built-in
        Django commands. User-supplied commands can override this method to
        return their own version.
        """
        return django.get_version()

    def create_parser(self, prog_name, subcommand, **kwargs):
        """
        Create and return the ``ArgumentParser`` which will be used to
        parse the arguments to this command.
        """
        parser = CommandParser(
            prog='%s %s' % (os.path.basename(prog_name), subcommand),
            description=self.help or None,
            formatter_class=DjangoHelpFormatter,
            missing_args_message=getattr(self, 'missing_args_message', None),
            called_from_command_line=getattr(self, '_called_from_command_line', None),
            **kwargs
        )
        parser.add_argument('--version', action='version', version=self.get_version())
        parser.add_argument(
            '-v', '--verbosity', default=1,
            type=int, choices=[0, 1, 2, 3],
            help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output',
        )
        parser.add_argument(
            '--settings',
            help=(
                'The Python path to a settings module, e.g. '
                '"myproject.settings.main". If this isn\'t provided, the '
                'DJANGO_SETTINGS_MODULE environment variable will be used.'
            ),
        )
        parser.add_argument(
            '--pythonpath',
            help='A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".',
        )
        parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions')
        parser.add_argument(
            '--no-color', action='store_true',
            help="Don't colorize the command output.",
        )
        self.add_arguments(parser)
        return parser

    def add_arguments(self, parser):
        """
        Entry point for subclassed commands to add custom arguments.
        """
        pass

</original_code>
<code_summary file_path="django/core/management/base.py" index="3">
- The `_called_from_command_line` and `stealth_options` attributes control how the command is executed and what options it accepts.
- The `__init__()` method sets up the output streams (stdout and stderr) and configures the color style for the command output.
- The `get_version()` method returns the Django version, which can be overridden by subclasses.
- The `create_parser()` method creates an `ArgumentParser` instance to parse the command-line arguments, including common options like `--settings`, `--pythonpath`, and `--verbosity`.
- The `add_arguments()` method is an entry point for subclasses to add custom arguments to the command.
</code_summary>

<original_code file_path="django/core/management/base.py" index="4">
    def print_help(self, prog_name, subcommand):
        """
        Print the help message for this command, derived from
        ``self.usage()``.
        """
        parser = self.create_parser(prog_name, subcommand)
        parser.print_help()

    def run_from_argv(self, argv):
        """
        Set up any environment changes requested (e.g., Python path
        and Django settings), then run this command. If the
        command raises a ``CommandError``, intercept it and print it sensibly
        to stderr. If the ``--traceback`` option is present or the raised
        ``Exception`` is not ``CommandError``, raise it.
        """
        self._called_from_command_line = True
        parser = self.create_parser(argv[0], argv[1])

        options = parser.parse_args(argv[2:])
        cmd_options = vars(options)
        # Move positional args out of options to mimic legacy optparse
        args = cmd_options.pop('args', ())
        handle_default_options(options)
        try:
            self.execute(*args, **cmd_options)
        except Exception as e:
            if options.traceback or not isinstance(e, CommandError):
                raise

            # SystemCheckError takes care of its own formatting.
            if isinstance(e, SystemCheckError):
                self.stderr.write(str(e), lambda x: x)
            else:
                self.stderr.write('%s: %s' % (e.__class__.__name__, e))
            sys.exit(1)
        finally:
            try:
                connections.close_all()
            except ImproperlyConfigured:
                # Ignore if connections aren't setup at this point (e.g. no
                # configured settings).
                pass

    def execute(self, *args, **options):
        """
        Try to execute this command, performing system checks if needed (as
        controlled by the ``requires_system_checks`` attribute, except if
        force-skipped).
        """
        if options['no_color']:
            self.style = no_style()
            self.stderr.style_func = None
        if options.get('stdout'):
            self.stdout = OutputWrapper(options['stdout'])
        if options.get('stderr'):
            self.stderr = OutputWrapper(options['stderr'], self.stderr.style_func)

        if self.requires_system_checks and not options.get('skip_checks'):
            self.check()
        if self.requires_migrations_checks:
            self.check_migrations()
        output = self.handle(*args, **options)
        if output:
            if self.output_transaction:
                connection = connections[options.get('database', DEFAULT_DB_ALIAS)]
                output = '%s\n%s\n%s' % (
                    self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()),
                    output,
                    self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()),
                )
            self.stdout.write(output)
        return output

</original_code>
<code_summary file_path="django/core/management/base.py" index="4">
- `print_help()`: This method creates a command-line argument parser using the `create_parser()` method, and then prints the help message for the command.
- `run_from_argv()`: This method is responsible for setting up the command-line environment, parsing the arguments, and then executing the command's logic. It first creates the argument parser, then parses the arguments and handles any default options. It then calls the `execute()` method, and handles any exceptions that may be raised.
- `execute()`: This method is where the actual command logic is implemented. It first checks the `no_color` and `force_color` options and adjusts the output style accordingly. It then performs any required system checks or migration checks, and finally calls the `handle()` method, which is where the subclasses of `BaseCommand` implement the specific logic of their command.
</code_summary>

<original_code file_path="django/core/management/base.py" index="5">
    def _run_checks(self, **kwargs):
        return checks.run_checks(**kwargs)

    def check(self, app_configs=None, tags=None, display_num_errors=False,
              include_deployment_checks=False, fail_level=checks.ERROR):
        """
        Use the system check framework to validate entire Django project.
        Raise CommandError for any serious message (error or critical errors).
        If there are only light messages (like warnings), print them to stderr
        and don't raise an exception.
        """
        all_issues = self._run_checks(
            app_configs=app_configs,
            tags=tags,
            include_deployment_checks=include_deployment_checks,
        )

        header, body, footer = "", "", ""
        visible_issue_count = 0  # excludes silenced warnings

        if all_issues:
            debugs = [e for e in all_issues if e.level < checks.INFO and not e.is_silenced()]
            infos = [e for e in all_issues if checks.INFO <= e.level < checks.WARNING and not e.is_silenced()]
            warnings = [e for e in all_issues if checks.WARNING <= e.level < checks.ERROR and not e.is_silenced()]
            errors = [e for e in all_issues if checks.ERROR <= e.level < checks.CRITICAL and not e.is_silenced()]
            criticals = [e for e in all_issues if checks.CRITICAL <= e.level and not e.is_silenced()]
            sorted_issues = [
                (criticals, 'CRITICALS'),
                (errors, 'ERRORS'),
                (warnings, 'WARNINGS'),
                (infos, 'INFOS'),
                (debugs, 'DEBUGS'),
            ]

            for issues, group_name in sorted_issues:
                if issues:
                    visible_issue_count += len(issues)
                    formatted = (
                        self.style.ERROR(str(e))
                        if e.is_serious()
                        else self.style.WARNING(str(e))
                        for e in issues)
                    formatted = "\n".join(sorted(formatted))
                    body += '\n%s:\n%s\n' % (group_name, formatted)

        if visible_issue_count:
            header = "System check identified some issues:\n"

        if display_num_errors:
            if visible_issue_count:
                footer += '\n'
            footer += "System check identified %s (%s silenced)." % (
                "no issues" if visible_issue_count == 0 else
                "1 issue" if visible_issue_count == 1 else
                "%s issues" % visible_issue_count,
                len(all_issues) - visible_issue_count,
            )

        if any(e.is_serious(fail_level) and not e.is_silenced() for e in all_issues):
            msg = self.style.ERROR("SystemCheckError: %s" % header) + body + footer
            raise SystemCheckError(msg)
        else:
            msg = header + body + footer

        if msg:
            if visible_issue_count:
                self.stderr.write(msg, lambda x: x)
            else:
                self.stdout.write(msg)

</original_code>
<code_summary file_path="django/core/management/base.py" index="5">
- The `_run_checks()` method is a helper method that calls the `checks.run_checks()` function to perform the system checks.
- The `check()` method first calls `_run_checks()` to get a list of all the issues found during the system checks.
- It then processes the list of issues, categorizing them by severity (debug, info, warning, error, critical) and formatting the output accordingly.
- If any serious issues (errors or critical errors) are found, the method raises a `SystemCheckError` exception.
- If only lighter issues (like warnings) are found, the method prints the output to stderr without raising an exception.
- The method uses the `self.style` object to apply appropriate styling (color, formatting) to the output, based on the severity of the issues.
</code_summary>

<original_code file_path="django/core/management/base.py" index="6">
    def check_migrations(self):
        """
        Print a warning if the set of migrations on disk don't match the
        migrations in the database.
        """
        from django.db.migrations.executor import MigrationExecutor
        try:
            executor = MigrationExecutor(connections[DEFAULT_DB_ALIAS])
        except ImproperlyConfigured:
            # No databases are configured (or the dummy one)
            return

        plan = executor.migration_plan(executor.loader.graph.leaf_nodes())
        if plan:
            apps_waiting_migration = sorted({migration.app_label for migration, backwards in plan})
            self.stdout.write(
                self.style.NOTICE(
                    "\nYou have %(unpplied_migration_count)s unapplied migration(s). "
                    "Your project may not work properly until you apply the "
                    "migrations for app(s): %(apps_waiting_migration)s." % {
                        "unpplied_migration_count": len(plan),
                        "apps_waiting_migration": ", ".join(apps_waiting_migration),
                    }
                )
            )
            self.stdout.write(self.style.NOTICE("Run 'python manage.py migrate' to apply them.\n"))

    def handle(self, *args, **options):
        """
        The actual logic of the command. Subclasses must implement
        this method.
        """
        raise NotImplementedError('subclasses of BaseCommand must provide a handle() method')


class AppCommand(BaseCommand):
    """
    A management command which takes one or more installed application labels
    as arguments, and does something with each of them.

    Rather than implementing ``handle()``, subclasses must implement
    ``handle_app_config()``, which will be called once for each application.
    """
    missing_args_message = "Enter at least one application label."

    def add_arguments(self, parser):
        parser.add_argument('args', metavar='app_label', nargs='+', help='One or more application label.')

    def handle(self, *app_labels, **options):
        from django.apps import apps
        try:
            app_configs = [apps.get_app_config(app_label) for app_label in app_labels]
        except (LookupError, ImportError) as e:
            raise CommandError("%s. Are you sure your INSTALLED_APPS setting is correct?" % e)
        output = []
        for app_config in app_configs:
            app_output = self.handle_app_config(app_config, **options)
            if app_output:
                output.append(app_output)
        return '\n'.join(output)

    def handle_app_config(self, app_config, **options):
        """
        Perform the command's actions for app_config, an AppConfig instance
        corresponding to an application label given on the command line.
        """
        raise NotImplementedError(
            "Subclasses of AppCommand must provide"
            "a handle_app_config() method.")


class LabelCommand(BaseCommand):
    """
    A management command which takes one or more arbitrary arguments
    (labels) on the command line, and does something with each of
    them.

    Rather than implementing ``handle()``, subclasses must implement
    ``handle_label()``, which will be called once for each label.

    If the arguments should be names of installed applications, use
    ``AppCommand`` instead.
    """
    label = 'label'
    missing_args_message = "Enter at least one %s." % label

    def add_arguments(self, parser):
        parser.add_argument('args', metavar=self.label, nargs='+')

    def handle(self, *labels, **options):
        output = []
        for label in labels:
            label_output = self.handle_label(label, **options)
            if label_output:
                output.append(label_output)
        return '\n'.join(output)

    def handle_label(self, label, **options):
        """
        Perform the command's actions for ``label``, which will be the
        string as given on the command line.
        """
        raise NotImplementedError('subclasses of LabelCommand must provide a handle_label() method')
</original_code>
<code_summary file_path="django/core/management/base.py" index="6">
- The `check_migrations()` method checks if there are any unapplied migrations in the project and prints a warning message if there are. It uses the `MigrationExecutor` class from the Django migrations framework to check the migration plan and determine which applications have unapplied migrations.
- The `handle()` method is the entry point for the command's logic. Subclasses of `BaseCommand` must implement this method, which contains the actual implementation of the command's functionality.
- The `AppCommand` class is a subclass of `BaseCommand` that is designed for commands that operate on one or more installed applications. It requires subclasses to implement the `handle_app_config()` method, which is called for each application specified as an argument.
- The `LabelCommand` class is a subclass of `BaseCommand` that is designed for commands that operate on one or more arbitrary labels (strings) provided as arguments. It requires subclasses to implement the `handle_label()` method, which is called for each label specified as an argument.
</code_summary>
</source>
</relevant_file>
<relevant_file index="1">
<file_path>
django/core/management/color.py
</file_path>
<source>
<original_code file_path="django/core/management/color.py" index="0">
"""
Sets up the terminal color scheme.
"""

import functools
import os
import sys

from django.utils import termcolors


def supports_color():
    """
    Return True if the running system's terminal supports color,
    and False otherwise.
    """
    plat = sys.platform
    supported_platform = plat != 'Pocket PC' and (plat != 'win32' or 'ANSICON' in os.environ)

    # isatty is not always implemented, #6223.
    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()
    return supported_platform and is_a_tty


class Style:
    pass


def make_style(config_string=''):
    """
    Create a Style object from the given config_string.

    If config_string is empty django.utils.termcolors.DEFAULT_PALETTE is used.
    """

    style = Style()

    color_settings = termcolors.parse_color_setting(config_string)

    # The nocolor palette has all available roles.
    # Use that palette as the basis for populating
    # the palette as defined in the environment.
    for role in termcolors.PALETTES[termcolors.NOCOLOR_PALETTE]:
        if color_settings:
            format = color_settings.get(role, {})
            style_func = termcolors.make_style(**format)
        else:
            def style_func(x):
                return x
        setattr(style, role, style_func)

    # For backwards compatibility,
    # set style for ERROR_OUTPUT == ERROR
    style.ERROR_OUTPUT = style.ERROR

    return style


@functools.lru_cache(maxsize=None)
def no_style():
    """
    Return a Style object with no color scheme.
    """
    return make_style('nocolor')


def color_style():
    """
    Return a Style object from the Django color scheme.
    """
    if not supports_color():
        return no_style()
    return make_style(os.environ.get('DJANGO_COLORS', ''))
</original_code>
<code_summary file_path="django/core/management/color.py" index="0">
- The `supports_color()` function checks if the running system's terminal supports color by checking the platform and whether the terminal is a TTY (a terminal interface).
- The `Style` class is an empty class that will be used to hold the color styles.
- The `make_style()` function creates a `Style` object from a given configuration string. If the configuration string is empty, it uses the default palette. It then populates the `Style` object with functions that apply the appropriate color formatting to different roles (e.g., ERROR, SUCCESS, WARNING).
- The `no_style()` function returns a `Style` object with no color scheme, using the `make_style()` function with the 'nocolor' configuration.
- The `color_style()` function returns a `Style` object from the Django color scheme. If the terminal does not support color, it returns the `no_style()` object.
</code_summary>
</source>
</relevant_file>
</relevant_files>

# GitHub Issue
<issue>
You are trying to resolve the following GitHub issue:
<original_github_issue>
Add an option to django-admin to always colorize output
Description
	
With Django management commands, it is currently possible disable colors with the --no-colors flag.
What I'd like to have is basically the other side of the coin: a --force-color flag that instructs Django to output ANSI color sequences in cases it would disable colors by default (typically, when the output is piped to another command, as documented).
My real world use-case is the following one: I have a custom Django command to import data. I run this command myself, and I'd like to send a colored log (HTML seems perfect for this) to the data curators. I can use the ​https://github.com/theZiz/aha utility for this, but that doesn't work since Django disable colors when the output is piped.
Other *nix commands have a special flag for this exact use-case, for example $ ls --color=always


Hi Nicolas. I'm going to Accept this: it seems reasonable. …in cases it would disable colors by default (typically, when the output is piped to another command, as documented). Can I ask, where is this documented? I cannot seem to find it. Thanks.
Thanks Carlton! It is documented in ​https://docs.djangoproject.com/en/2.0/ref/django-admin/#syntax-coloring: The django-admin / manage.py commands will use pretty color-coded output if your terminal supports ANSI-colored output. It won’t use the color codes if you’re piping the command’s output to another program.
Thanks Nicolas. I just found that. (I must have been blind: I even looked in that exact location... sigh :-)
I unfortunately can't find time in the short term to work on the implementation...
PR​https://github.com/django/django/pull/10213
This looks good to me. (I had a couple of tiny comment which I assume will be addressed, so progressing.) Thanks Hasan. Add an error message stating that 'The --no-color and --force-color options can't be used together.' when the command is executed. If BaseCommand is initalized with both enabled, error with ''no_color' and 'force_color' can't be used together.' In addition, add '--force_color' to DjangoHelpFormatter.
</original_github_issue>

You have previously made the following changes:
<changes_made>
File: django/core/management/base.py
--- 
+++ 
@@ -88,21 +88,21 @@
     return wrapped
 
 
 class DjangoHelpFormatter(HelpFormatter):
     """
     Customized formatter so that command-specific arguments appear in the
     --help output before arguments common to all commands.
     """
     show_last = {
         '--version', '--verbosity', '--traceback', '--settings', '--pythonpath',
-        '--no-color',
+        '--no-color', '--force-color',
     }
 
     def _reordered_actions(self, actions):
         return sorted(
             actions,
             key=lambda a: set(a.option_strings) & self.show_last != set()
         )
 
     def add_usage(self, usage, actions, *args, **kwargs):
         super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)
@@ -272,20 +272,24 @@
             ),
         )
         parser.add_argument(
             '--pythonpath',
             help='A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".',
         )
         parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions')
         parser.add_argument(
             '--no-color', action='store_true',
             help="Don't colorize the command output.",
+        )
+        parser.add_argument(
+            '--force-color', action='store_true',
+            help="Force colorization of the command output.",
         )
         self.add_arguments(parser)
         return parser
 
     def add_arguments(self, parser):
         """
         Entry point for subclassed commands to add custom arguments.
         """
         pass
 
@@ -332,25 +336,29 @@
                 # Ignore if connections aren't setup at this point (e.g. no
                 # configured settings).
                 pass
 
     def execute(self, *args, **options):
         """
         Try to execute this command, performing system checks if needed (as
         controlled by the ``requires_system_checks`` attribute, except if
         force-skipped).
         """
+        if options['no_color'] and options['force_color']:
+            raise CommandError("The --no-color and --force-color options can't be used together.")
         if options['no_color']:
             self.style = no_style()
             self.stderr.style_func = None
+        if options['force_color']:
+            self.style = color_style(force_color=True)
         if options.get('stdout'):
-            self.stdout = OutputWrapper(options['stdout'])
+            self.stdout = OutputWrapper(options['stdout'], style_func=self.style.OUTPUT)
         if options.get('stderr'):
             self.stderr = OutputWrapper(options['stderr'], self.stderr.style_func)
 
         if self.requires_system_checks and not options.get('skip_checks'):
             self.check()
         if self.requires_migrations_checks:
             self.check_migrations()
         output = self.handle(*args, **options)
         if output:
             if self.output_transaction:

File: django/core/management/color.py
--- 
+++ 
@@ -57,17 +57,17 @@
 
 
 @functools.lru_cache(maxsize=None)
 def no_style():
     """
     Return a Style object with no color scheme.
     """
     return make_style('nocolor')
 
 
-def color_style():
+def color_style(force_color=False):
     """
     Return a Style object from the Django color scheme.
     """
-    if not supports_color():
+    if not force_color and not supports_color():
         return no_style()
     return make_style(os.environ.get('DJANGO_COLORS', ''))
</changes_made>

However, the following GitHub Actions failed with the following logs:
<github_actions_logs>
    utility.execute()
  File "/mnt/sweep_benchmark/django__django-10213/django/core/management/__init__.py", line 376, in execute
    self.fetch_command(subcommand).run_from_argv(self.argv, force_color=options.force_color)
TypeError: run_from_argv() got an unexpected keyword argument 'force_color'
'

======================================================================
FAIL: test_disallowed_abbreviated_options (user_commands.tests.CommandRunTests)
To avoid conflicts with custom options, commands don't allow
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/mnt/sweep_benchmark/django__django-10213/tests/user_commands/tests.py", line 255, in test_disallowed_abbreviated_options
    self.assertNoOutput(err)
  File "/mnt/sweep_benchmark/django__django-10213/tests/admin_scripts/tests.py", line 189, in assertNoOutput
    self.assertEqual(len(stream), 0, "Stream should be empty: actually contains '%s'" % stream)
AssertionError: 543 != 0 : Stream should be empty: actually contains 'Traceback (most recent call last):
  File "./manage.py", line 15, in <module>
    execute_from_command_line(sys.argv)
  File "/mnt/sweep_benchmark/django__django-10213/django/core/management/__init__.py", line 382, in execute_from_command_line
    utility.execute()
  File "/mnt/sweep_benchmark/django__django-10213/django/core/management/__init__.py", line 376, in execute
    self.fetch_command(subcommand).run_from_argv(self.argv, force_color=options.force_color)
TypeError: run_from_argv() got an unexpected keyword argument 'force_color'
'

======================================================================
FAIL: test_script_prefix_set_in_commands (user_commands.tests.CommandRunTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/mnt/sweep_benchmark/django__django-10213/tests/user_commands/tests.py", line 245, in test_script_prefix_set_in_commands
    self.assertNoOutput(err)
  File "/mnt/sweep_benchmark/django__django-10213/tests/admin_scripts/tests.py", line 189, in assertNoOutput
    self.assertEqual(len(stream), 0, "Stream should be empty: actually contains '%s'" % stream)
AssertionError: 543 != 0 : Stream should be empty: actually contains 'Traceback (most recent call last):
  File "./manage.py", line 15, in <module>
    execute_from_command_line(sys.argv)
  File "/mnt/sweep_benchmark/django__django-10213/django/core/management/__init__.py", line 382, in execute_from_command_line
    utility.execute()
  File "/mnt/sweep_benchmark/django__django-10213/django/core/management/__init__.py", line 376, in execute
    self.fetch_command(subcommand).run_from_argv(self.argv, force_color=options.force_color)
TypeError: run_from_argv() got an unexpected keyword argument 'force_color'
'

----------------------------------------------------------------------
Ran 215 tests in 32.505s

FAILED (failures=140, errors=23)
Destroying test database for alias 'default'…
Destroying test database for alias 'other'…

</github_actions_logs>
</issue>

Your job is to write a high quality, detailed, step-by-step plan for an intern to help resolve a user's GitHub issue.

You will analyze the provided code files, repository, and GitHub issue to understand the requested change. Create a step-by-step plan for an intern to fully resolve the user's GitHub issue. The plan should utilize the relevant code files and utility modules provided. Give detailed instructions for updating the code logic, as the intern is unfamiliar with the codebase.

Guidelines:
- Always include the full file path and reference the provided files 
- Provide clear instructions for updating the code, specifying necessary imports
- Be specific and direct, using the phrases "add", "replace", and "remove".
- Reference relevant type definitions, interfaces, and schemas 
- Ensure your plan is complete and covers all necessary changes to fully resolve the issue
- Suggest high-quality, safe, maintainable, efficient and backwards compatible changes
- Prioritize using existing code and utility methods to minimize writing new code
- Break the task into small steps, with each <create> or <modify> section for each logical code block worth of change. Use multiple <modify> blocks for the same file if there are multiple distinct changes to make in that file.
- To remove code, replace it with empty <new_code> tags.

Please use the following XML format for your response:

# 1. Issue Analysis:
<issue_analysis>
a. Identify the root cause of the issue by referencing specific code entities in the relevant files.

b. Detail ALL of the changes that need to made to resolve the user request. Reference the provided code files, summaries, entity names, and necessary files/directories. Be complete and precise. (1 paragraph)

c. List ALL of the files we should modify to resolve the issue. Reference the provided code files, summaries, entity names, and necessary files/directories. Respond in the following format:
  - File path 1: Detailed instructions for modifying the file.
      a. Describe the first change to make in the file.
      b. Describe the second change to make in the file.
      c. Continue listing all changes that need to be made. Be complete and precise.
  - File path 2: Detailed instructions for modifying the file.
      a. Describe the first change to make in the file.
      b. Describe the second change to make in the file.
      c. Continue listing all changes that need to be made. Be complete and precise.
[additional files as needed]

d. List ALL relevant read-only utility modules from the provided set and specify where they can be used. These are not files you need to make changes to but files you need to read while making changes in other files, including:
  - Type definitions, interfaces, and schemas
  - Helper functions
  - Frontend components
  - Database services
  - API endpoints
  [additional relevant modules as needed]
</issue_analysis>

# 2. Plan:
<plan>  
<create file="file_path_1">
Instructions for creating the new file. Reference imports and entity names. Include relevant type definitions, interfaces, and schemas.
</create>
[additional creates]

<modify file="file_path_2"> 
Instructions for modifying one section of the file. 

1. Reference the original code in <original_code> tags, copying them VERBATIM from the file. Do NOT paraphrase or abbreviate the source code. Placeholder comments like "# existing code" are not permitted.

2. Write the new code in <new_code> tags, specifying necessary imports and referencing relevant type definitions, interfaces, and schemas. BE EXACT as this code will replace the mentioned <original_code>.
</modify>

<modify file="file_path_2">
Instructions for modifying a different section of the same file. 

1. Reference the original code in <original_code> tags, copying them VERBATIM from the file. Do NOT paraphrase or abbreviate the source code. Placeholder comments like "# existing code" are not permitted.

2. Write the new code in <new_code> tags, specifying necessary imports and referencing relevant type definitions, interfaces, and schemas. BE EXACT as this code will replace the mentioned <original_code>.

Use multiple <modify> blocks for the same file to separate distinct changes.
</modify>

[additional modifies as needed, for the same file or different files]
</plan>

# 3. Relevant Modules:
<relevant_modules>
[List of all relevant files to reference while making changes, one per line] 
</relevant_modules>